<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<title>ヒストグラムから中央値・分位点を求める</title>
<link rel="stylesheet" href="style.css">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
</head>
<body>

<nav id="breadcrumbs">
<a href="../">ホーム</a> &gt;
<a href="./">Python</a> &gt;
</nav>

<h1>ヒストグラムから中央値・分位点を求める</h1>

<p><em>[追記]</em> 中央値については中澤港先生の作られたRのパッケージ fmsb の <a href="https://minato.sip21c.org/msb/man/truemedian.html">truemedian</a> という関数にすでに実装されていました（中澤先生にご指摘いただきました。ありがとうございます）。truemedian は次のような実装になっています：</p>

<pre>
function (X, h = 1) 
{
    YY &lt;- rep(0, length(X))
    XX &lt;- table(X)
    q &lt;- length(XX)
    k &lt;- 0
    for (i in 1:q) {
        L &lt;- as.numeric(names(XX)[i]) - h/2
        for (j in 1:XX[[i]]) {
            k &lt;- k + 1
            YY[k] &lt;- L + h * (2 * j - 1)/(2 * XX[[i]])
        }
    }
    return(median(YY))
}
</pre>

<p>これを以下と同じ仕様にして Python で書けばこんな感じ：</p>

<pre class="cell">
def hmedian(hist):
    a = np.array([])
    for i, h in enumerate(hist):
        if h != 0:
            a = np.append(a, np.arange(1, 2 * h, 2) / (2 * h) + (i - 0.5))
    return np.median(a)
</pre>

<hr>

<p>国立感染症研究所の<time>2022-01-13</time>の<a href="https://www.niid.go.jp/niid/ja/2019-ncov/2551-cepr/10903-b11529-period.html">SARS-CoV-2の変異株B.1.1.529系統（オミクロン株）の潜伏期間の推定：暫定報告</a>では，度数分布から中央値を求めるために，ガンマ分布でフィットして，中央値2.9日（95%信頼区間2.6-3.2）を出している。以下では特別なモデルを仮定せず各ビンの中では一様分布（分布関数が折れ線）として度数分布データから中央値（一般に分位点）を求めてみる。</p>

<p>上の「データ1」はオミクロン株曝露-発症間隔（0，1，2，3，4，5日）の度数分布を表す次のような <span lang="en"><i>N</i> = 35</span> のデータである。</p>

<pre class="cell">
hist = [0, 2, 8, 15, 9, 1]
</pre>

<p><a href="dotplot.html">ドットプロット</a>：</p>

<figure><img src="img/dotplot.svg" alt="ドットプロット"></figure>

<p>このようなデータの中央値を求めるのが問題である。</p>

<p><span lang="en"><i>N</i> = 35</span> であるから，18番目の値が中央値である。18番目は3のビンに入るので，3のビンの15個がすべて3に等しければ，中央値は3である。</p>

<p>そうではなく，ここでは3のビンのデータは2.5から3.5までの範囲に一様分布すると仮定しよう。ここで考えているデータでは，0日目の正午に暴露したと仮定するのと同じことである。もし3のビンのデータが3から4までの範囲とするのであれば，以下の結果に0.5を加えればよい。</p>

<p>このデータでは，3未満のビンには10個あるのだから，3のビンの15個中で8番目が中央値である。15個の8番目はちょうど中央であるので，こう考えても中央値は 3.0 になるとしてよさそうである。国立感染症研究所の結果（2.9日）ともほぼ一致する。</p>

<p>これは，次の累積分布で 35/2 のところを求めることに相当する。</p>

<figure><img src="img/dotplot-cum.svg" alt="ドットプロットの累積分布"></figure>

<p>より一般的に，度数分布で与えられる分布で，各ビン内では一様分布と仮定する場合，中央値は次の式で計算できる：</p>

<div style="text-indent:2em">中央値 = 中央値を含むビンの左端 + (<span lang="en"><i>N</i>/2</span> - 中央値を含むビン未満の度数の合計) / 中央値を含むビンの度数 × 中央値を含むビンの幅</div>

<p>この場合にあてはめると 2.5 + (35/2 - 10) / 15 * 1 = 3.0 となり，さきほどの結果と一致する。</p>

<p>より一般に，階級値 0, 1, 2, 3, … についての度数のリスト <code>hist</code> が与えられたとき，このような中央値を求めるには，次のようにする：</p>

<pre class="cell">
def hmedian(hist):
    n = sum(hist)
    i = 0
    s = hist[i]
    while s &lt; n / 2:
        i += 1
        s += hist[i]
    return i + (n / 2 - s) / hist[i] + 0.5
</pre>

<p>これでいいと思っていたら，<code>[1, 1, 0, 1, 1]</code> のような真ん中が 0 の場合に，対称性を破る値を出してしまう。</p>

<!--
<p>とりあえず，両側から攻めて，結果を平均するようにしてみた：</p>

<pre class="cell">
def hmedian(hist):
    n = sum(hist)
    i = 0
    s = hist[i]
    while s &lt; n / 2:
        i += 1
        s += hist[i]
    m1 = i + (n / 2 - s) / hist[i] + 0.5
    i = len(hist) - 1
    s = hist[i]
    while s &lt; n / 2:
        i -= 1
        s += hist[i]
    m2 = i - (n / 2 - s) / hist[i] - 0.5
    return (m1 + m2) / 2
</pre>

-->

<p>次のようにすればよさそうである：</p>

<pre class="cell">
def hmedian(hist):
    n = sum(hist)
    i = 0
    s = hist[i]
    while s &lt; n / 2:
        i += 1
        s += hist[i]
    if s == n / 2 and hist[i + 1] == 0:
        j = i + 2
        while hist[j] == 0:
            j += 1
        return (i + j) / 2
    return i + (n / 2 - s) / hist[i] + 0.5
</pre>

<p>ここで <code>n / 2</code> を別の値に変えれば任意の分位点が求められる。このことを使って一般化したのが次の関数である。<code>q</code> に0より大きく1より小さい値を与える。例えば0.25を与えれば四分位数を出力する。</p>

<pre class="cell">
def hquantile(hist, q=0.5):
    n = sum(hist)
    t = n * q
    i = 0
    s = hist[i]
    while s &lt; t:
        i += 1
        s += hist[i]
    if s == t and hist[i + 1] == 0:
        j = i + 2
        while hist[j] == 0:
            j += 1
        return (i + j) / 2
    return i + (t - s) / hist[i] + 0.5
</pre>

<p>データがヒストグラムではなく自然数のリストで与えられているときは，例えば次のようにしてヒストグラムに直す：</p>

<pre class="cell">
import numpy as np

a = [0, 1, 1, 3, 5]  # リストで与えられたデータ
hist, bin_edges = np.histogram(a, range(max(a) + 2))
</pre>

<p><code>bin_edges</code> は無視すればよい。</p>

<p>逆に，ヒストグラムをデータに直すには次のようにする：</p>

<pre class="cell">
np.repeat(range(len(hist)), hist)
</pre>

<p>ブートストラップを使えば分位点の信頼区間も求められる。</p>

<pre class="cell">
rng = np.random.default_rng(20220129)

hist = [0, 2, 8, 15, 9, 1]
m = len(hist)
n = sum(hist)
x = np.repeat(range(m), hist)

def func():
    y = rng.choice(x, n)
    h, _ = np.histogram(y, range(m + 1))
    return hmedian(h)

r = [func() for _ in range(10000)]
np.quantile(r, [0.025, 0.975])
</pre>

<pre>
array([2.66666667, 3.33333333])
</pre>

<p>中央値の95%信頼区間はだいたい [2.67, 3.33] である。</p>

<p>この方法では区間の上下限は ..., 2.650, 2.656, 2.667, 2.675, 2.679, ..., 3.325, 3.333, 3.344, ... のような離散的な値しかとりえない。極端な場合，ビンが一つしかなければ，一つの値しかとりえないので，信頼区間は狭めに出ることが考えられる。</p>

<hr>

<p><em>[追記]</em> <a href="https://twitter.com/hyd3nekosuki/status/1488415587907043328">遠藤先生のバージョン</a>：</p>

<pre class="cell">
rng = np.random.default_rng(20220201)

hist = [0, 2, 8, 15, 9, 1]
n = sum(hist)
x = np.repeat(range(len(hist)), hist)

def func():
    return np.median(rng.choice(x, n) + rng.random(n)) - 0.5

r = [func() for _ in range(10000)]
np.quantile(r, [0.025, 0.975])
</pre>

<pre>
array([2.62720809, 3.37747261])
</pre>

<pre class="cell">
r = [func() for _ in range(100000)]
np.quantile(r, [0.025, 0.975])
</pre>

<pre>
array([2.62591919, 3.37426923])
</pre>

<p>中央値の95%信頼区間はだいたい [2.63, 3.37] である。さきほどの結果よりほんの少し広くなった。</p>

<p>この方法なら信頼区間の上下限は稠密な値をとりうる。ビンが一つでも正しい信頼区間が出る。</p>

<hr>

<p><a href="../" rel="author">奥村 晴彦</a></p>

<p>
<!-- hhmts start -->
Last modified: <time>2022-02-02 22:11:40</time>
<!-- hhmts end -->
</p>
</body>
</html>
