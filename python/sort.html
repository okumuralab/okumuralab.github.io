<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<title>並べ替え（整列）</title>
<link rel="stylesheet" href="style.css">
<link rel="license" href="http://creativecommons.org/licenses/by/4.0/">
</head>
<body>

<nav id="breadcrumbs">
<a href="/~okumura/">ホーム</a> &gt;
<a href="./">Python</a> &gt;
</nav>

<h1>並べ替え（整列）</h1>

<p>Python には小さい順に並べ替える関数が二つあります。<code>sort()</code> と <code>sorted()</code> です。この違いを，例で体験してみましょう。</p>

<pre>
<code>In [ ]: a = [3, 5, 2, 4, 1]   # 適当なリストを作る

In [ ]: sorted(a)             # 並べ替えたリストを返す
Out[ ]: [1, 2, 3, 4, 5]       # 並べ変わっている

In [ ]: a                     # 元のリスト a は
Out[ ]: [3, 5, 2, 4, 1]       # 並べ変わっていない

In [ ]: a.sort()              # リストをその場で並べ替える

In [ ]: a                     # 元のリスト a が
Out[ ]: [1, 2, 3, 4, 5]       # 並べ変わっている

In [ ]: sorted("I have an apple".lower().split())
Out[ ]: ['an', 'apple', 'have', 'i']  # 文字列は辞書順に
</code></pre>

<p>デフォルトでは昇順になります。降順にするには <code>reverse=True</code> というオプションを与えます。</p>

<p>並べ替えをする簡単な関数を作ってみましょう。いろいろなアルゴリズムがありますが，次のものは選択ソート（selection sort）というものです：</p>

<pre>
<code>def selectsort(a):
    n = len(a)
    for i in range(n):
        k = i
        for j in range(i + 1, n):
            if a[j] &lt; a[k]:
                k = j
        a[i], a[k] = a[k], a[i]
</code></pre>

<p>最後の行は <code>a[i]</code> と <code>a[k]</code> の値を交換しています。Python ならこのように簡単に書けます。</p>

<p>うまくいくか試してみましょう：</p>

<pre>
<code>In [ ]: a = [3, 5, 2, 4, 1]   # 適当なリストを作る

In [ ]: selectsort(a)         # うまくいくかな？

In [ ]: a                     # 元のリスト a は
Out[ ]: [1, 2, 3, 4, 5]       # 並べ変わっている
</code></pre>

<p>もっと速いアルゴリズムとしてクイックソート（quicksort）が知られています：</p>

<pre>
<code>def quicksort(a, first=0, last=None):
    if last is None:
        last = len(a) - 1
    x = a[(first + last) // 2]
    i = first
    j = last
    while True:
        while a[i] &lt; x:
            i += 1
        while x &lt; a[j]:
            j -= 1
        if i &gt;= j:
            break
        a[i], a[j] = a[j], a[i]
        i += 1
        j -= 1
    if first &lt; i - 1:
        quicksort(a, first, i - 1)
    if j + 1 &lt; last:
        quicksort(a, j + 1, last)
</code></pre>

<div class="note">
<p><code>def quicksort(a, first=0, last=len(a)-1):</code> としたいかもしれませんが，Python の引数のデフォルトの値は関数定義を評価したときに決まってしまうので，期待した動作になりません。ここでは，何もないことを表すオブジェクト <code>None</code> をデフォルトの値として，関数の実行時にもし <code>None</code> であれば <code>len(a) - 1</code> に置き換えています。<code>if last is None:</code> は <code>if last == None:</code> と似ていますが <code>==</code> は値の比較，<code>is</code> はオブジェクトのアドレスの比較です。後者の方が速く，しかも <code>==</code> のようにオーバーライド（上書き）できないので確実な比較ができます。</p>
</div>

<p>時間を比べてみましょう。Wall time が実時間（壁にかかっている時計で計った時間）です：</p>

<pre>
<code>In [ ]: import random

In [ ]: a = [random.random() for _ in range(10000)]

In [ ]: %time selectsort(a)
CPU times: user 3.41 s, sys: 1.99 ms, total: 3.41 s
Wall time: 3.41 s

In [ ]: a = [random.random() for _ in range(10000)]

In [ ]: %time quicksort(a)
CPU times: user 23.3 ms, sys: 743 µs, total: 24 ms
Wall time: 23.5 ms
</code></pre>

<p>Python の <code>sort()</code> や <code>sorted()</code> は <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> というアルゴリズムを使っています。</p>

<p>NumPy にも整列の関数があります。</p>

<pre>
<code>import numpy as np

rng = np.random.default_rng()
a = rng.random(1000)
b = np.sort(a)  # 上書きするなら a.sort()
</code></pre>

<p>降順に並べ替えるオプションはありませんが，<code>a[::-1]</code> で逆順にできます。</p>

<hr>

<p><a href="../" rel="author">奥村 晴彦</a></p>

<p>
<!-- hhmts start -->
Last modified: <time>2020-11-24 14:01:10</time>
<!-- hhmts end -->
</p>
</body>
</html>
